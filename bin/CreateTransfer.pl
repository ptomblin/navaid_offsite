#!/usr/bin/perl -w
#File CreateCoPilotDB.pl
#
#	This file creates a transfer file.  It's designed to run in the
#	background, spawned by Apache.
#
#   This file is copyright (c) 2001 by Paul Tomblin, and may be distributed
#   under the terms of the "Clarified Artistic License", which should be
#   bundled with this file.  If you receive this file without the Clarified
#   Artistic License, email ptomblin@xcski.com and I will mail you a copy.
#

BEGIN
{
    push @INC, "/www/navaid.com/perl";
}

use strict;
use Getopt::Long;
use CreateDB;
use WaypointTypes;

# Parameters
my $pgm = "Transfer";
my $url = "http://navaid.com/Transfer/";
my $xfrfile = "waypoint.txt";
my $logfile = "waypoint.log";
my $all = 0;
my @countries = ();
my @states = ();
my @provinces = ();
my @types = ();
#my @notes = ();
my $max_lat = 91;
my $min_lat = -91;
my $max_long = 181;
my $min_long = -181;
my $private = 1;
my $public = 1;
my $metric = 0;
my $longCountry = 0;

GetOptions(
	"xfrname=s" => \$xfrfile,
	"logname=s" => \$logfile,
    "all!" => \$all,
    "country=s@" => \@countries,
    "state=s@" => \@states,
    "province=s@" => \@provinces,
    "private!" => \$private,
    "public!" => \$public,
    "metric!" => \$metric,
    "expandCountry!" => \$longCountry,
    "max_lat=f" => \$max_lat,
    "min_lat=f" => \$min_lat,
    "max_long=f" => \$max_long,
    "min_long=f" => \$min_long);

print "xfrname = $xfrfile\n";
print "logname = $logfile\n";
print "all = $all\n";
print "private = $private\n";
print "public = $public\n";
print "metric = $metric\n";
print "expandCountry = $longCountry\n";
print "countries = " . join(",",@countries) . "\n";
print "states = " . join(",",@states) . "\n";
print "provinces = " . join(",",@provinces) . "\n";
print "types = " . join(",",@types) . "\n";
print "max_lat = $max_lat\n";
print "min_lat = $min_lat\n";
print "max_long = $max_long\n";
print "min_long = $min_long\n";

my $doType = 1;
my $doNavFreq = 1;
my $doRunways = 1;
my $doMilFreq = 1;
my $doCommFreq = 1;
my $doTPA = 1;
my $doFix = 1;

my %param = (
	"min_lat" => $min_lat,
	"max_lat" => $max_lat,
	"min_long" => $min_long,
	"max_long" => $max_long,
	"doRunways" => $doRunways,
	"doComm" => $doMilFreq||$doCommFreq,
	"doTPA" => $doTPA,
	"doFix" => $doFix,
	"longCountry" => $longCountry);
if (scalar(@countries) > 0)
{
	$param{countries} = \@countries;
}
if (scalar(@states) > 0)
{
	$param{states} = \@states;
}
if (scalar(@provinces) > 0)
{
	$param{provinces} = \@provinces;
}
if ($private && !$public)
{
	$param{privacy} = 1;
}
elsif (!$private && $public)
{
	$param{privacy} = 0;
}
else
{
    $param{privacy} = 2;
}
if (scalar(@types) > 0)
{
	$param{types} = \@types;
}

# XXX Maybe do some error checking.

# 
open(LOGFILE, ">".$logfile);
my $ofh = select(LOGFILE); $| = 1; select $ofh;
print LOGFILE "$pgm 0";

my $maxDebug = 0;

my $rowInc = 100;
my $maxRowNum = undef;

open(DEBUG,">>/www/navaid.com/tmp/CreateTransfer" . ($maxDebug?"_test":"") .
		".out");
if ($maxDebug)
{
    $ofh = select(DEBUG); $| = 1; select $ofh;
}

sub sigEndHandler
{
	my ($sig) = @_;

	# Get rid of the log file so that the app knows it failed.
	close(LOGFILE);
	unlink($logfile);
}

sub normalizeDegrees($)
{
    my $deg = shift;

    $deg *= 1.0;

    while ($deg < 0.0)
    {
        $deg += 360.0;
    }
    while ($deg >= 360.0)
    {
        $deg -= 360.0;
    }
    return sprintf("%.1f", $deg);
}

open(XFER, ">$xfrfile");
print XFER (<<EOF);
# Generated by NAVAID database generator at
# $url
# 
# The format is as follows:
#
# For Airport types: (AIRPORT, BALLOONPORT, GLIDERPORT, HELIPORT,
# PLATFORM, SEAPLANE BASE, STOLPORT, ULTRALIGHT, PARACHUTE):
#  type,ident,name,province/state,country,N/S,dd,mm,ss,W/E,dd,mm,ss,dW/E,elev[,privateYN]
#  RWY,nn/nn,length,width,surface[,N/S,dd,mm,ss,W/E,dd,mm,ss,heading,elev,N/S,dd,mm,ss,W/E,dd,mm,ss,heading,elev]
#  COMM,type,name,freq
#  TPA,pattern altitude
#  NOTE,text
# RWY, COMM, and NOTE are repeated as many times as necessary for each
# one.
# The beginning and end latitude, longitude, heading and elevation of a
# runway aren't present in many datasources so they're optional.
# Elevations, traffic pattern altitudes and runway lengths/widths are
# assumed to be in feet, unless you follow the number with 'm' for metres.
#
# For navaid types: (DME, DVOR/DME, FAN MARKER, MARINE NDB, NDB, NDB/DME,
# TACAN, TVOR, TVOR/DME, UHF/NDB, UNSPECIFIED NAVAID, VOR, VOR/DME,
# VOR/TACAN, VORTAC, VOT)
#  type,ident,name,province/state,country,N/S,dd,mm,ss,W/E,dd,mm,ss,dW/E,freq
#
# For waypoint types: (AWY-INTXN, CNF, COORDN-FIX, GPS-WP, MIL-REP-PT,
# MIL-WAYPOINT, NRS-WAYPOINT, RADAR, REP-PT, RNAV-WP, VFR-WP, WAYPOINT)
#  type,ident,name,province/state,country,N/S,dd,mm,ss,W/E,dd,mm,ss,dW/E,sectional,ifr-lo,ifr-hi,iap,rnav
#  FIX,navaid,type,radial,distance
# FIX is repeated as many times as neccessary for each one.  Distances are
# assumed to be in nautical miles, unless the number is followed by "km"
# for kilometres.
#
# If you want to delete a waypoint, leave the type, ident, name,
# province/state and country alone, and change the rest of the record to
# DELETE.  If you want to leave it alone and not change anything, delete
# it from the file.
#
# Blank lines, and those starting with #, are to be ignored.
#
EOF

sub dbSourceCode($)
{
    my $hashRef = shift;
}

sub debugCode($)
{
	my $line = shift;
	if ($maxDebug)
	{
		print DEBUG $line;
	}
}

sub convLatLong($$)
{
	my ($posnegStr, $decdeg) = @_;

	my $firstChar = substr($posnegStr, (($decdeg < 0)?1:0), 1);

	$decdeg = abs($decdeg);

	my $intdeg = int($decdeg);
	my $min = ($decdeg - $intdeg) * 60;
	my $intmin = int($min);
	my $sec = ($min - $intmin) * 60;
	$sec = int($sec * 100 + 0.5) / 100.0;

	return ($firstChar, $intdeg, $intmin, $sec);
}

my @records = ();

sub wayPointCode($)
{
    my ($record) = @_;
	if (defined($record->{id}))
	{
		my $rownum = $record->{rownum};
		if (($rownum % $rowInc) == 0)
		{
			print LOGFILE "\n$pgm $rownum";
		}
        push @records, $record;
    }
	else
	{
        $maxRowNum = $record->{rownum};
	}
    return 1;
}

sub printResults()
{
    foreach my $record (
        sort
        {
            if ($a->{category} == $b->{category})
            {
                return $a->{id} cmp $b->{id};
            }
            return $a->{category} <=> $b->{category};
        } @records)
    {
        my ($ns, $latdeg, $latmin, $latsec) = convLatLong("NS",
            $record->{latitude});
        my ($ew, $londeg, $lonmin, $lonsec) = convLatLong("EW",
            $record->{longitude});
        my ($dwe, $decdeg, $decmin, $decsec) = convLatLong("WE",
            $record->{declination});

        if ($record->{category} == 1)
        {
            print XFER $record->{type}.",".$record->{id}.",".
                $record->{name}.",".
                (defined($record->{state}) ? $record->{state} : ""), .",".
                $record->{country}.",".
                $ns.",".$latdeg.",".$latmin.",".$latsec.",".
                $ew.",".$londeg.",".$lonmin.",".$lonsec.",".
                $decdeg.$dwe.",".
                feetToMetres($record->{elevation}).",".
                $record->{private}."\n";

            print XFER formatRunways($record->{runways});
            print XFER formatCommFreqs($record->{frequencies}, $doMilFreq,
                    $doCommFreq);
            if ($doTPA && defined($record->{tpa}) &&
                $record->{tpa} ne "")
            {
                print XFER "TPA," . $record->{tpa} . "\n";
            }
        }
        elsif ($record->{category} == 2)
        {
            print XFER $record->{type}.",".$record->{id}.",".
                $record->{name}.",".$record->{state}.",".
                $record->{country}.",".
                $ns.",".$latdeg.",".$latmin.",".$latsec.",".
                $ew.",".$londeg.",".$lonmin.",".$lonsec.",".
                $decdeg.$dwe.",".
                $record->{main_frequency}."\n";
        }
        else
        {
            my $chart_map = $record->{chart_map};
            print XFER $record->{type}.",".$record->{id}.",".
                $record->{name}.",".$record->{state}.",".
                $record->{country}.",".
                $ns.",".$latdeg.",".$latmin.",".$latsec.",".
                $ew.",".$londeg.",".$lonmin.",".$lonsec.",".
                $decdeg.$dwe.",".
                (($chart_map & WaypointTypes::WPTYPE_VFR) ? 'Y' : 'N').",".
                (($chart_map & WaypointTypes::WPTYPE_LOW_ENROUTE) ? 'Y' : 'N').",".
                (($chart_map & WaypointTypes::WPTYPE_HIGH_ENROUTE) ? 'Y' : 'N').",".
                (($chart_map & WaypointTypes::WPTYPE_APPROACH) ? 'Y' : 'N').",".
                (($chart_map & WaypointTypes::WPTYPE_RNAV) ? 'Y' : 'N')."\n";
            print XFER formatFix($record->{fixinfo});
        }
    }
}

sub formatCommFreqs($$$)
{
    my ($commFreqRef, $mil, $nonmil) = @_;
    my $retstring = "";

    foreach my $rowRef (@{$commFreqRef})
    {
		my $comm_type = $rowRef->{type};
		my $frequency = $rowRef->{frequency};
		my $comm_name = $rowRef->{name};

        my ($numFreq, $suffix) = ($frequency =~ m/^([0-9\.]*)([A-Z]*)$/);
        my $milfreq = ($numFreq < 108.0 || $numFreq > 137.0) &&
                            ($suffix eq "" || $suffix eq "M");
        if (($mil && $milfreq) || ($nonmil && !$milfreq))
        {
			my $thisStr = "COMM,$comm_type,$comm_name,$frequency\n";
            $retstring .= $thisStr;
        }
    }
    return $retstring;
}

sub feetToMetres($)
{
  my $feet = shift;
  if ($metric)
  {
	$feet = int($feet * .3048 + .5);
    $feet .= "m";
  }
  return $feet;
}

sub formatRunways($)
{
    my ($runwaysRef) = shift;
    my $retstring = "";

    foreach my $rowRef (@{$runwaysRef})
    {
		my $runway_designation = $rowRef->{designation};
		my $length = feetToMetres($rowRef->{length});
		my $width = feetToMetres($rowRef->{width});
		my $surface = $rowRef->{surface};
        $retstring .= "RWY,$runway_designation,$length,$width,$surface";
        if (defined($rowRef->{b_lat}) && defined($rowRef->{b_long}) &&
            defined($rowRef->{e_lat}) && defined($rowRef->{e_long}))
        {
            my ($ns, $latdeg, $latmin, $latsec) = convLatLong("NS",
                $rowRef->{b_lat});
            my ($ew, $londeg, $lonmin, $lonsec) = convLatLong("EW",
                $rowRef->{b_long});
            $retstring .= ",$ns,$latdeg,$latmin,$latsec,".
                "$ew,$londeg,$lonmin,$lonsec,";
            if (defined($rowRef->{b_heading}))
            {
                $retstring .= normalizeDegrees($rowRef->{b_heading});
            }
            $retstring .= ",";
            if (defined($rowRef->{b_elev}))
            {
                $retstring .= $rowRef->{b_elev};
            }
            $retstring .= ",";

            ($ns, $latdeg, $latmin, $latsec) = convLatLong("NS",
                $rowRef->{e_lat});
            ($ew, $londeg, $lonmin, $lonsec) = convLatLong("EW",
                $rowRef->{e_long});
            $retstring .= ",$ns,$latdeg,$latmin,$latsec,".
                "$ew,$londeg,$lonmin,$lonsec,";

            if (defined($rowRef->{e_heading}))
            {
                $retstring .= normalizeDegrees($rowRef->{e_heading});
            }
            $retstring .= ",";
            if (defined($rowRef->{e_elev}))
            {
                $retstring .= $rowRef->{e_elev};
            }
        }
        $retstring .= "\n";
    }
    return $retstring;
}

sub formatFix($)
{
    my ($fixRef) = shift;

    my $retstring = "";

    foreach my $rowRef (@{$fixRef})
    {
		my $navaid = $rowRef->{navaid};
		my $type = $rowRef->{navaid_type};
		my $radial = $rowRef->{radial_bearing};
		my $distance = $rowRef->{distance};

        if (!defined($radial))
        {
            $radial = "";
        }
        if (!defined($distance))
        {
            $distance = "";
        }
        if (!defined($distance))
        {
            $distance = "";
        }
        $retstring .= "FIX,$navaid,$type,$radial,$distance\n";
    }
    return $retstring;
}

CreateDB::generate(\%param, \&wayPointCode, \&dbSourceCode, \&debugCode);

if (defined($maxRowNum))
{
    printResults();
    print LOGFILE "\n$pgm FINISHED ", $maxRowNum, " ", $xfrfile ;
    close(LOGFILE);
    close(XFER);
}
else
{
	close(LOGFILE);
	unlink($logfile);
    close(XFER);
    unlink($xfrfile);
}
